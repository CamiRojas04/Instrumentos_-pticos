import numpy as np
import matplotlib.pyplot as plt
from matplotlib.gridspec import GridSpec
from scipy.special import j1 

# Aperturas

def generar_apertura_circular(N, L, radio):
    """apertura circular."""
    coords = np.linspace(-L / 2, L / 2, N)
    X, Y = np.meshgrid(coords, coords)
    R = np.sqrt(X**2 + Y**2)
    apertura = np.zeros((N, N))
    apertura[R <= radio] = 1.0
    return apertura.astype(np.complex128)

# Cálculo Teórico

def calcular_patron_airy(N, L_salida, longitud_onda, distancia_z, radio_apertura):
    """Calcula el patrón de difracción teórico de Fraunhofer (disco de Airy)"""
    coords = np.linspace(-L_salida / 2, L_salida / 2, N)
    X, Y = np.meshgrid(coords, coords)
    R = np.sqrt(X**2 + Y**2)
    k = 2 * np.pi / longitud_onda
    
    # Argumento de la función de Bessel
    epsilon = 1e-9
    argumento = k * radio_apertura * R / distancia_z + epsilon
    
    # Fórmula del patrón de Airy: I(r) = (2*J1(arg)/arg)^2
    intensidad = (2 * j1(argumento) / argumento)**2
    
    # Se normaliza para que el pico máximo sea 1
    return intensidad / np.max(intensidad) if np.max(intensidad) > 0 else intensidad


# Núcleo - Física

def calcular_difraccion_fresnel_analizada(campo_entrada, L_entrada, longitud_onda, distancia_z):
    N, _ = campo_entrada.shape 
    k = 2 * np.pi / longitud_onda 
    delta_x0 = L_entrada / N 
    x0_coords = np.linspace(-L_entrada / 2, L_entrada / 2, N)
    X0, Y0 = np.meshgrid(x0_coords, x0_coords) 
    fase_entrada = np.exp((1j * k / (2 * distancia_z)) * (X0**2 + Y0**2)) 
    campo_preparado = campo_entrada * fase_entrada
    campo_transformado = np.fft.fftshift(np.fft.fft2(np.fft.ifftshift(campo_preparado)))
    delta_x_salida = (longitud_onda * distancia_z) / (N * delta_x0) 
    L_salida = delta_x_salida * N
    x_salida_coords = np.linspace(-L_salida / 2, L_salida / 2, N)
    X_salida, Y_salida = np.meshgrid(x_salida_coords, x_salida_coords) 
    factor_escala = (np.exp(1j * k * distancia_z) / (1j * longitud_onda * distancia_z)) * \
                     np.exp(1j * k / (2 * distancia_z) * (X_salida**2 + Y_salida**2))                
    campo_final = factor_escala * (delta_x0**2) * campo_transformado
    
    intensidad_salida = np.abs(campo_final)**2 
    return intensidad_salida, L_salida 

def verificar_muestreo_fresnel(N, L, longitud_onda, distancia_z):
    """
    Verifica si se cumple la condición de muestreo para evitar aliasing,
    basado en la estructura z >= N * delta_x0^2 / lambda 
    """
    if longitud_onda <= 0 or N <= 0:
        return False, "Parámetros inválidos (lambda o N)."

    # Tamaño del píxel en el plano de entrada
    delta_x0 = L / N

    # Distancia mínima de propagación para evitar aliasing 
    z_min = (N * delta_x0**2) / longitud_onda
    
    # La condición de muestreo se cumple si la distancia de propagación actual
    # es mayor o igual a esta distancia mínima.
    if distancia_z >= z_min:
        return True, f"Muestreo Válido (z={distancia_z:.3f}m >= z_min={z_min:.3f}m)"
    else:
        return False, f"¡Riesgo de Aliasing! (z={distancia_z:.3f}m < z_min={z_min:.3f}m)"


if __name__ == '__main__':

    # ===================================================================
    # --- PARÁMETROS DE LA SIMULACIÓN ---
    # ===================================================================

    longitud_onda = 633e-9  # Longitud de onda de la luz (m)
    N = 1028       # Resolución (número de muestras en un eje, N x N)


    distancia_z = 6
    L_entrada = 0.1
    radio = 0.005 


    # Verificar Nyquist 
    valido, msg = verificar_muestreo_fresnel(N, L_entrada, longitud_onda, distancia_z)
    print("-----------------------------------------")
    print(f"Estado de la Simulación: {msg}")
    if not valido:
        print("Aliasing")


    # apertura circular
    campo_entrada = generar_apertura_circular(N, L_entrada, radio)

    # simulación de Fresnel
    intensidad_sim, L_salida = calcular_difraccion_fresnel_analizada(
        campo_entrada, L_entrada, longitud_onda, distancia_z)

    # solución analítica de Airy
    intensidad_airy = calcular_patron_airy(
        N, L_salida, longitud_onda, distancia_z, radio)

    # conf y mostrar los gráficos
    fig = plt.figure(figsize=(12, 8))
    gs = GridSpec(2, 2, figure=fig, height_ratios=[1, 2.5], hspace=0.4, wspace=0.3)
    
    ax_apertura = fig.add_subplot(gs[0, :])
    ax_simulacion = fig.add_subplot(gs[1, 0])
    ax_analitica = fig.add_subplot(gs[1, 1])
    
    # Gráfico de la Apertura
    ax_apertura.set_title("Apertura", fontsize='medium')
    ax_apertura.imshow(np.abs(campo_entrada)**2, cmap='gray', 
                       extent=[-L_entrada/2*1e3, L_entrada/2*1e3, -L_entrada/2*1e3, L_entrada/2*1e3], 
                       origin='lower', interpolation='bicubic')
    ax_apertura.set_xlabel("x₀ (mm)")
    ax_apertura.set_ylabel("y₀ (mm)")
    ax_apertura.set_aspect('equal', adjustable='box')


    # Se calcula el radio del primer mínimo del disco de Airy para centrar la vista.
    # r_airy = 1.22 * lambda * z / D, donde D es el diámetro (2*radio)
    radio_primer_minimo = 1.22 * longitud_onda * distancia_z / (2 * radio)
    # Establecemos un límite de visualización para ver algunos anillos (ej. 3 veces el radio del primer mínimo)
    limite_visualizacion = 3 * radio_primer_minimo

    # Normalización 
    intensidad_sim_norm = np.log1p(intensidad_sim)
    
    # Simulación
    ax_simulacion.set_title("Simulación Numérica (Fresnel)")
    ax_simulacion.imshow(intensidad_sim_norm, cmap='inferno', 
                         extent=[-L_salida/2*1e3, L_salida/2*1e3, -L_salida/2*1e3, L_salida/2*1e3], 
                         origin='lower',
                         interpolation='bicubic') # Interpolación para suavizar la imagen
    ax_simulacion.set_xlabel("x (mm)")
    ax_simulacion.set_ylabel("y (mm)")
    ax_simulacion.set_xlim(-limite_visualizacion * 1e3, limite_visualizacion * 1e3)
    ax_simulacion.set_ylim(-limite_visualizacion * 1e3, limite_visualizacion * 1e3)
    ax_simulacion.set_aspect('equal', adjustable='box') # Garantiza que no haya distorsión

    # Solución Analítica
    max_sim_val = np.max(intensidad_sim)
    #  intensidad de Airy normalizada
    intensidad_airy_norm = np.log1p(intensidad_airy * max_sim_val)

    ax_analitica.set_title("Solución Analítica (Airy)")
    ax_analitica.imshow(intensidad_airy_norm, cmap='inferno', 
                        extent=[-L_salida/2*1e3, L_salida/2*1e3, -L_salida/2*1e3, L_salida/2*1e3], 
                        origin='lower',
                        interpolation='bicubic') # Interpolación para suavizar la imagen
    ax_analitica.set_xlabel("x (mm)")
    ax_analitica.set_ylabel("y (mm)")
    ax_analitica.set_xlim(-limite_visualizacion * 1e3, limite_visualizacion * 1e3)
    ax_analitica.set_ylim(-limite_visualizacion * 1e3, limite_visualizacion * 1e3)
    ax_analitica.set_aspect('equal', adjustable='box') # Garantiza que no haya distorsión


    fig.suptitle("Comparación de Difracción: Simulación Numérica vs. Solución Analítica", fontsize=16)
    fig.tight_layout(rect=[0, 0, 1, 0.95])
    
    plt.show()

